import { Query } from "./Query.js";
import { EJSON } from "bson";
export class Client {
    getHeaders() {
        return {
            'Content-Type': 'application/ejson',
            'Access-Control-Request-Headers': '*',
            'api-key': this._apiKey,
        };
    }
    getActionUrl(action) {
        return this._atlasEndpoint + "/action/" + action;
    }
    /**
     * Excecute an aggregate operation
     * @param collection collection name
     * @param pipeline pipeline
     * @returns
     */
    async aggregate(collection, pipeline) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.pipeline = pipeline;
            const response = await this._request(this.getActionUrl("aggregate"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "aggregate");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error);
        }
        return result;
    }
    /**
     * find a single document
     * @param collection collection name
     * @param filter filter
     * @param options options
     * @returns
     */
    async findOne(collection, filter, options) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            if (options) {
                if (options.sort)
                    body.sort = options.sort;
                if (options.limit)
                    body.limit = options.limit;
                if (options.skip)
                    body.skip = options.skip;
                if (options.projection)
                    body.projection = options.projection;
            }
            const response = await this._request(this.getActionUrl("findOne"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "findOne");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * find multiple documents
     * @param collection collection name
     * @param filter filter
     * @param options options
     * @returns
     */
    async find(collection, filter, options) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            if (options) {
                if (options.sort)
                    body.sort = options.sort;
                if (options.limit)
                    body.limit = options.limit;
                if (options.skip)
                    body.skip = options.skip;
                if (options.projection)
                    body.projection = options.projection;
            }
            const response = await this._request(this.getActionUrl("find"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "find");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * insert a single document
     * @param collection collection name
     * @param document document
     * @returns
     */
    async insertOne(collection, document) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.document = document;
            const response = await this._request(this.getActionUrl("insertOne"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "insertOne");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * insert multiple documents
     * @param collection collection name
     * @param documents documents
     * @returns
     */
    async insertMany(collection, documents) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.documents = documents;
            const response = await this._request(this.getActionUrl("insertMany"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "insertMany");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * delete single document
     * @param collection collection name
     * @param filter filter
     * @returns
     */
    async deleteOne(collection, filter) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            const response = await this._request(this.getActionUrl("deleteOne"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "deleteOne");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * delete multiple documents
     * @param collection collection name
     * @param filter filter
     * @returns
     */
    async deleteMany(collection, filter) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            const response = await this._request(this.getActionUrl("deleteMany"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "deleteMany");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * update a single document
     * @param collection collection name
     * @param filter filter
     * @param update update filter
     * @param upsert upsert
     * @returns
     */
    async updateOne(collection, filter, update, upsert = false) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            body.update = update;
            body.upsert = upsert;
            const response = await this._request(this.getActionUrl("updateOne"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "updateOne");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * update multiple documents
     * @param collection collection name
     * @param filter filter
     * @param update update filter
     * @param upsert upsert
     * @returns
     */
    async updateMany(collection, filter, update, upsert = false) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            body.update = update;
            body.upsert = upsert;
            const response = await this._request(this.getActionUrl("updateMany"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "updateMany");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * replace a document
     * @param collection collection name
     * @param filter filter
     * @param data replacement data
     * @param upsert upsert
     * @returns
     */
    async replaceOne(collection, filter, data, upsert = false) {
        let result = null;
        try {
            const body = new Query({ dataSource: this._dataSource, database: this._database, collection });
            body.filter = filter;
            body.replacement = data;
            body.upsert = upsert;
            const response = await this._request(this.getActionUrl("replaceOne"), body, this.getHeaders(), (obj) => EJSON.stringify(obj), "replaceOne");
            result = JSON.parse(response);
        }
        catch (error) {
            if (this._log)
                this._log(error.message);
            else
                console.log(error.message);
        }
        return result;
    }
    /**
     * Constructor of the Client
     * @param cData the connection data with the api key, database/datasource and atlas endpoint
     * @param request the request handler
     * @param log optional log function, if not passed console.log will be used
     */
    constructor(cData, request, log) {
        this._atlasEndpoint = cData.atlasEndPoint;
        this._apiKey = cData.apikey;
        this._database = cData.database;
        this._dataSource = cData.dataSource;
        this._log = log;
        this._request = request;
    }
}
//# sourceMappingURL=Client.js.map