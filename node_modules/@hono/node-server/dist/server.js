"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serve = exports.createAdaptorServer = void 0;
const node_http_1 = require("node:http");
const fetch_1 = require("./fetch");
const stream_1 = require("./stream");
const globals_1 = require("./globals");
(0, globals_1.installGlobals)();
const createAdaptorServer = (options) => {
    const fetchCallback = options.fetch;
    const requestListener = getRequestListener(fetchCallback);
    const server = (0, node_http_1.createServer)(options.serverOptions || {}, requestListener);
    return server;
};
exports.createAdaptorServer = createAdaptorServer;
const serve = (options) => {
    const server = (0, exports.createAdaptorServer)(options);
    server.listen(options.port || 3000);
    return server;
};
exports.serve = serve;
const getRequestListener = (fetchCallback) => {
    return async (incoming, outgoing) => {
        const method = incoming.method || 'GET';
        const url = `http://${incoming.headers.host}${incoming.url}`;
        const headerRecord = {};
        const len = incoming.rawHeaders.length;
        for (let i = 0; i < len; i++) {
            if (i % 2 === 0) {
                const key = incoming.rawHeaders[i];
                headerRecord[key] = incoming.rawHeaders[i + 1];
            }
        }
        const init = {
            method: method,
            headers: headerRecord,
        };
        if (!(method === 'GET' || method === 'HEAD')) {
            const buffers = [];
            for await (const chunk of incoming) {
                buffers.push(chunk);
            }
            const buffer = Buffer.concat(buffers);
            init['body'] = buffer;
        }
        let res;
        try {
            res = (await fetchCallback(new Request(url.toString(), init)));
        }
        catch {
            res = new fetch_1.Response(null, { status: 500 });
        }
        const contentType = res.headers.get('content-type') || '';
        const contentEncoding = res.headers.get('content-encoding');
        for (const [k, v] of res.headers) {
            if (k === 'set-cookie') {
                outgoing.setHeader(k, res.headers.getAll(k));
            }
            else {
                outgoing.setHeader(k, v);
            }
        }
        outgoing.statusCode = res.status;
        if (res.body) {
            if (!contentEncoding && contentType.startsWith('text')) {
                outgoing.end(await res.text());
            }
            else if (!contentEncoding && contentType.startsWith('application/json')) {
                outgoing.end(await res.text());
            }
            else {
                await (0, stream_1.writeReadableStreamToWritable)(res.body, outgoing);
            }
        }
        else {
            outgoing.end();
        }
    };
};
